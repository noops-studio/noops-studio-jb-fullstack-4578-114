
# components/app/App.css
.App {
    height: 100%;
}
# components/app/App.tsx
// components/app/App.tsx
import { BrowserRouter } from "react-router-dom";
import { Provider } from "react-redux";
import Routing from "../layout/routing/Routing";
import store from "../../redux/store";
import "./App.css";
import Auth from "../auth/Auth";

export default function App(): JSX.Element {
  return (
    <div className="App">
      <BrowserRouter>
        <Provider store={store}>
          <Auth>
          <Routing />
          </Auth>
        </Provider>
      </BrowserRouter>
    </div>
  );
}

# components/auth/Auth.tsx
import { createContext, PropsWithChildren, useState } from "react";


interface AuthContextInterface {
    jwt: string;
    newLogin: React.Dispatch<React.SetStateAction<string>>;
    
}

export const AuthContext = createContext<AuthContextInterface | null>(null);


export default function Auth(props:PropsWithChildren): JSX.Element {

    const JWT_KEY = 'jwt';

    const [jwt, setJwt] = useState<string>(localStorage.getItem(JWT_KEY) ||'');

function newLogin(jwt: string) {
    localStorage.setItem(JWT_KEY, jwt);
    setJwt(jwt);
}

const {children} = props;

    return(
        <AuthContext.Provider value={{jwt, newLogin}}>
            {children}
        </AuthContext.Provider>
    )
}
# components/common/Loading.tsx
import React, { useState } from 'react';

interface LoadingProps {
  isLoading: boolean;
  error?: string;
  onRetry?: () => void;
}

export default function Loading({ isLoading, error, onRetry }: LoadingProps) {
  const [showError, setShowError] = useState(!!error);

  const handleCloseError = () => setShowError(false);

  return (
    <>
      {isLoading && (
        <div className="fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-50 z-50">
          <div className="w-16 h-16 border-4 border-t-blue-500 border-t-4 border-gray-200 rounded-full animate-spin"></div>
        </div>
      )}

      {showError && (
        <div className="fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-50 z-50">
          <div className="bg-white rounded-lg shadow-lg w-11/12 max-w-md p-6">
            <h2 className="text-2xl font-semibold text-red-600 mb-4 text-center">
              Error
            </h2>
            <p className="text-gray-700 text-center mb-6">{error}</p>
            <div className="flex justify-end gap-4">
              <button
                className="px-4 py-2 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400"
                onClick={handleCloseError}
              >
                Close
              </button>
              {onRetry && (
                <button
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
                  onClick={onRetry}
                >
                  Retry
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </>
  );
}

# components/common/ProtectedRoute.tsx
// components/common/ProtectedRoute.tsx
import { Navigate } from "react-router-dom";

interface ProtectedRouteProps {
  element: JSX.Element;
}

export default function ProtectedRoute({ element }: ProtectedRouteProps): JSX.Element {
  const isAuthenticated = (): boolean => {
    // Check for 'auth' cookie or token logic
    return document.cookie.split("; ").some((cookie) => cookie.startsWith("auth="));
  };

  return isAuthenticated() ? element : <Navigate to="/login" replace />;
}

# components/common/setTitle.ts
import { useEffect } from "react";

export default function setTitle(title: string) {
    useEffect(() => {
        document.title = title;
    }, [title]);
}
# components/common/TinyEditor.tsx
import React from 'react';
import { Editor } from '@tinymce/tinymce-react';

interface TinyEditorProps {
  value: string;
  onChange: (content: string) => void;
  placeholder?: string;
  height?: number;
}

export default function TinyEditor({
  value,
  onChange,
  placeholder = 'Type your content here...',
  height = 300,
}: TinyEditorProps) {
  return (
    <Editor
      apiKey={import.meta.env.VITE_TINYMCE_KEY}
      value={value}
      init={{
        height,
        menubar: false,
        plugins: ['lists', 'link', 'emoticons'],
        toolbar: 'undo redo | bold italic | bullist numlist outdent indent | emoticons',
        placeholder,
        content_style: `
          body {
            font-family: Arial, sans-serif;
            font-size: 14px;
            line-height: 1.6;
          }
        `,
      }}
      onEditorChange={onChange}
    />
  );
}

# components/layout/editPost/EditPost.tsx
import React, { useState } from "react";
import EditPostUi from "./EditPostUi";
import PostModel from "../../../models/posts/Post";

interface EditPostProps {
  post: PostModel;
  onDelete: (id: string) => Promise<boolean>;
  onSavePost: (updatedPost: { title: string; body: string; postId: string }) => Promise<void>;
}

export default function EditPost({ post, onDelete, onSavePost }: EditPostProps) {
  const { id, title, body, createdAt } = post;

  const handleSavePost = async (updatedPost: { title: string; body: string; postId: string }) => {
    await onSavePost(updatedPost);
  };

  const handleDelete = async () => {
    if (confirm("Are you sure you want to delete this post?")) {
      await onDelete(id);
    }
  };

  return (
    <div className="p-4 bg-white shadow-md rounded-lg mb-6">
      {/* Post Header */}
      <div className="flex justify-between items-center mb-4">
        <div>
          <h3 className="text-lg font-semibold text-gray-800">{title}</h3>
          <p className="text-sm text-gray-500">
            Created at {new Date(createdAt).toLocaleString()}
          </p>
        </div>
        <div className="flex space-x-2">
          {/* Edit Post Button */}
          <EditPostUi title={title} body={body} postId={id} onSave={handleSavePost} />

          {/* Delete Button */}
          <button
            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
            onClick={handleDelete}
          >
            Delete
          </button>
        </div>
      </div>

      {/* Post Body */}
      <div className="prose">
        <div dangerouslySetInnerHTML={{ __html: body }} />
      </div>
    </div>
  );
}

# components/layout/editPost/EditPostUi.tsx
import React, { useState } from 'react';
import TinyEditor from '../../common/TinyEditor';

interface EditPostUiProps {
  title: string;
  body: string;
  postId: string;
  onSave: (updatedPost: { title: string; body: string; postId: string }) => Promise<void>;
}

export default function EditPostUi({ title, body, postId, onSave }: EditPostUiProps) {
  const [postTitle, setPostTitle] = useState(title);
  const [postBody, setPostBody] = useState(body);
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleOpenModal = () => setIsModalOpen(true);
  const handleCloseModal = () => setIsModalOpen(false);

  const handleConfirmUpdate = async () => {
    setIsModalOpen(false);
    await onSave({ title: postTitle, body: postBody, postId });
  };

  return (
    <div className="text-center">
      <button
        className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
        onClick={handleOpenModal}
      >
        Edit Post
      </button>

      {isModalOpen && (
        <div className="fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-50 z-50">
          <div className="bg-white rounded-lg shadow-lg w-11/12 max-w-3xl p-6">
            <h2 className="text-2xl font-semibold text-gray-800 mb-4 text-center">Edit Post</h2>

            <div className="mb-6">
              <label
                htmlFor="post-title"
                className="block text-gray-700 text-sm font-medium mb-1"
              >
                Title
              </label>
              <input
                id="post-title"
                type="text"
                value={postTitle}
                onChange={(e) => setPostTitle(e.target.value)}
                placeholder="Enter a title for your post"
                className="block w-full border border-gray-300 rounded-lg shadow-sm px-4 py-2 text-base focus:ring-blue-500 focus:border-blue-500 focus:outline-none transition duration-200 placeholder-gray-400 hover:shadow-md"
              />
            </div>

            <div className="mb-6">
              <label
                htmlFor="post-body"
                className="block text-gray-700 text-sm font-medium mb-1"
              >
                Body
              </label>
              <TinyEditor value={postBody} onChange={setPostBody} />
            </div>

            <div className="flex justify-end gap-4">
              <button
                className="px-4 py-2 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400"
                onClick={handleCloseModal}
              >
                Cancel
              </button>
              <button
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
                onClick={handleConfirmUpdate}
              >
                Save
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

# components/layout/follow/FollowButton.tsx
import React, { useState } from "react";
import { Button } from "@mui/material";
import followerService from "../../../services/auth-aware/FollowersService";

interface FollowButtonProps {
  userId: string;
  isFollowing: boolean; // Whether the user is currently following
  onUpdate: () => void; // Callback to refresh the followers/following list
}

const FollowButton: React.FC<FollowButtonProps> = ({ userId, isFollowing, onUpdate }) => {
  const [loading, setLoading] = useState(false);

  const handleFollowUnfollow = async () => {
    setLoading(true);
    try {
      if (isFollowing) {
        await followerService.unfollowUser(userId);
      } else {
        await followerService.followUser(userId);
      }
      onUpdate(); // Refresh the followers and following list
    } catch (error) {
      alert(`Failed to ${isFollowing ? "unfollow" : "follow"} user. Please try again.`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button
      variant="contained"
      color={isFollowing ? "secondary" : "primary"}
      onClick={handleFollowUnfollow}
      disabled={loading}
    >
      {loading ? "Processing..." : isFollowing ? "Unfollow" : "Follow"}
    </Button>
  );
};

export default FollowButton;

# components/layout/following/Following.css

# components/layout/following/Following.tsx
import { useEffect } from "react";
import "./Following.css";
import FollowingUi from "./FollowingUi";
import followerService from "../../../services/auth-aware/FollowersService";
import { useAppDispatch, useAppSelector } from "../../../redux/hooks";
import { init, unfollow } from "../../../redux/followingSlice";

export default function Followings(): JSX.Element {
  const following = useAppSelector((state) => state.following.following);
  const dispatch = useAppDispatch();

  useEffect(() => {
    const fetchData = async () => {
      try {
        const followingData = await followerService.getFollowing();
        dispatch(init(followingData));
      } catch (error) {
        console.error("Failed to fetch following list:", error);
      }
    };
    fetchData();
  }, [dispatch]);

  const handleUnfollow = async (userId: string) => {
    try {
      await followerService.unfollowUser(userId);
      dispatch(unfollow(userId)); // Update Redux store
    } catch (error) {
      console.error("Failed to unfollow user:", error);
    }
  };

  return (
    <div className="h-full">
      <h1 className="text-lg font-semibold mb-4">Following List</h1>
      <FollowingUi
        following={following}
        onUnfollow={handleUnfollow} // Pass handler to UI
      />
    </div>
  );
}

# components/layout/following/FollowingUi.tsx
import React from "react";

interface FollowingProps {
  following: { id: string; name: string; isFollowing: boolean }[];
  onUnfollow: (userId: string) => void; // Callback to handle unfollow
}

const FollowingUi: React.FC<FollowingProps> = ({ following, onUnfollow }) => {
  return (
    <div className="flex flex-col p-4 bg-gray-50 rounded-md shadow-md max-h-80 overflow-y-auto">
      {following.map(({ id, name }) => (
        <div
          key={id}
          className="flex items-center justify-between p-4 bg-white border border-gray-300 rounded-lg shadow-sm mb-2"
        >
          <div className="flex items-center space-x-4">
            <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white text-lg font-semibold shadow-lg">
              {name[0].toUpperCase()}
            </div>
            <span className="text-gray-800 font-medium text-sm">{name}</span>
          </div>
          <button
            onClick={() => onUnfollow(id)}
            className="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600"
          >
            Unfollow
          </button>
        </div>
      ))}
      {following.length === 0 && (
        <p className="text-gray-500 text-center">No users being followed.</p>
      )}
    </div>
  );
};

export default FollowingUi;

# components/layout/folowers/Folowers.css

# components/layout/folowers/Folowers.tsx
// # components/layout/folowers/Folowers.tsx
import { useEffect } from "react";
import "./Folowers.css";
import FollowersUi from "./FolowersUi";
import followerService from "../../../services/auth-aware/FollowersService";
import { useAppDispatch, useAppSelector } from "../../../redux/hooks";
import { init as initFollowers } from "../../../redux/followersSlice";
import { init as initFollowing } from "../../../redux/followingSlice";
import { fetchProfilePosts } from "../../../redux/profileSlice";
import feed from "../../../services/Feed";

export default function Folowers(): JSX.Element {
  const followers = useAppSelector((state) => state.followers.followers || []);
  const dispatch = useAppDispatch();

  // Function to fetch all necessary data
  const fetchData = async () => {
    try {
      // Fetch followers, following lists, and feed data in parallel
      const [followersData, followingData] = await Promise.all([
        followerService.getFollowers(),
        followerService.getFollowing(),
      ]);
      
      // Update both states
      dispatch(initFollowers(followersData));
      dispatch(initFollowing(followingData));

      // Re-fetch feed data
      await feed.getFeed();
      
      // Also refresh profile posts if needed
      dispatch(fetchProfilePosts());
    } catch (error) {
      console.error("Failed to fetch data:", error);
    }
  };

  useEffect(() => {
    fetchData();
  }, [dispatch]);

  const handleFollowUnfollow = async (userId: string, isCurrentlyFollowing: boolean) => {
    try {
      if (isCurrentlyFollowing) {
        await followerService.unfollowUser(userId);
      } else {
        await followerService.followUser(userId);
      }
      
      // Refresh all data after follow/unfollow action
      await fetchData();
    } catch (error) {
      console.error("Failed to follow/unfollow user:", error);
    }
  };

  return (
    <div className="h-full">
      <h1 className="text-lg font-semibold mb-4">Followers List</h1>
      <FollowersUi 
        followers={followers} 
        onFollowUnfollow={handleFollowUnfollow} 
      />
    </div>
  );
}
# components/layout/folowers/FolowersUi.tsx
// # components/layout/folowers/FolowersUi.tsx
interface FollowersProps {
  followers: { id: string; name: string; isFollowing: boolean }[];
  onFollowUnfollow: (userId: string, isFollowing: boolean) => Promise<void>;
}

const FollowersUi: React.FC<FollowersProps> = ({ followers, onFollowUnfollow }) => {
  return (
    <div className="flex flex-col p-4 bg-gray-50 rounded-md shadow-md max-h-80 overflow-y-auto">
      {followers.map(({ id, name, isFollowing }) => (
        <div
          key={id}
          className="flex items-center justify-between p-4 bg-white border border-gray-300 rounded-lg shadow-sm mb-2"
        >
          <div className="flex items-center space-x-4">
            <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white text-lg font-semibold shadow-lg">
              {name ? name[0].toUpperCase() : "?"}
            </div>
            <span className="text-gray-800 font-medium text-sm">{name || "Unknown"}</span>
          </div>
          <button
            onClick={async () => {
              try {
                await onFollowUnfollow(id, isFollowing);
              } catch (error) {
                console.error("Error following/unfollowing user:", error);
              }
            }}
            className={`px-4 py-2 rounded-md text-sm font-semibold transition-colors duration-200 focus:outline-none shadow-md ${
              isFollowing
                ? "bg-red-500 text-white hover:bg-red-600"
                : "bg-blue-500 text-white hover:bg-blue-600"
            }`}
          >
            {isFollowing ? "Unfollow" : "Follow"}
          </button>
        </div>
      ))}
      {followers.length === 0 && (
        <p className="text-gray-500 text-center">No followers yet.</p>
      )}
    </div>
  );
};

export default FollowersUi;
# components/layout/footer/Footer.css

# components/layout/footer/Footer.tsx
import './Footer.css'

export default function Footer() {
    return (
      <div className="bg-gray-800 text-white text-center py-4">
        <p>Server is {import.meta.env.VITE_REST_SERVER_URL}</p>
      </div>
    );
  }
  
# components/layout/header/Header.css
.Header {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center; /* Ensures alignment of nav and logo */
    padding: 10px;
    background-color: #f8f9fa; /* Light gray background, similar to Bootstrap's */
    border-bottom: 1px solid #dee2e6; /* Add subtle border */
}

.Header nav {
    display: flex;
    flex-direction: row;
    gap: 15px; /* Adjust spacing between nav links */
}

.logob {
    width: 100px;
    height: 100px;
    margin: 0 auto;
    display: block;
    border-radius: 50%; /* Optional: make logo circular */
}

.nav-link {
    text-decoration: none;
    color: #495057; /* Default text color */
    font-weight: 500;
    padding: 5px 10px;
    border-radius: 5px; /* Rounded corners */
    transition: all 0.2s ease-in-out;
}

.nav-link.active {
    color: #fff; /* Active link text color */
    background-color: #007bff; /* Bootstrap primary color for active link */
}

.nav-link:hover {
    color: #007bff; /* Change text color on hover */
}

# components/layout/header/Header.tsx
// Header.tsx
import useUsername from '../../../hooks/useUsername';
import { ResponsiveAppBar } from './MuiHeader';

export default function Header() {
  const links = [
    { path: '/profile', name: 'Profile', type: 'menu' as const },
    { path: '/feed', name: 'Feed', type: 'menu' as const },
    { path: '/logout', name: 'Logout', type: 'settings' as const },
    { path: '/logouta', name: 'Logouta', type: 'settings' as const },
  ];

  const profilePicUrl = "https://cdn.ozari.co.il/beery/noop.jpeg"; // Replace with dynamic URL
  const username = useUsername();

  return (
    <ResponsiveAppBar
      links={links}
      profilePicUrl={profilePicUrl}
      username={username}
    />
  );
}

# components/layout/header/MuiHeader.tsx
import React, { useContext, useMemo, useState } from "react";
import { NavLink } from "react-router-dom";
import { AuthContext } from "../../auth/Auth";
import { jwtDecode } from "jwt-decode";
import User from "../../../models/users/Users";

interface Link {
  path: string;
  name: string;
  type: "menu" | "settings";
}

interface ResponsiveAppBarProps {
  links: Link[];
  profilePicUrl: string;
  username: string;
}

export const ResponsiveAppBar: React.FC<ResponsiveAppBarProps> = ({
  links,
  profilePicUrl,
  username,
}) => {
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const menuLinks = links.filter((link) => link.type === "menu");
  const settingsLinks = links.filter((link) => link.type === "settings");

  const toggleDropdown = () => setDropdownOpen((prev) => !prev);

  return (
    <header className="bg-blue-600 text-white shadow-md">
      <div className="container mx-auto px-4 flex justify-between items-center h-16">
        <div className="flex items-center space-x-4">
          <span className="text-xl font-bold">LOGO</span>
          <nav className="hidden md:flex space-x-4">
            {menuLinks.map((link) => (
              <NavLink
                key={link.name}
                to={link.path}
                className={({ isActive }) =>
                  `text-white ${
                    isActive ? "underline font-semibold" : "hover:opacity-80"
                  }`
                }
              >
                {link.name}
              </NavLink>
            ))}
          </nav>
        </div>
        <div className="flex items-center space-x-4">
          <div className="relative">
            <button
              className="flex items-center space-x-2"
              onClick={toggleDropdown}
            >
              <img
                src={profilePicUrl}
                alt={`${username} profile`}
                className="w-8 h-8 rounded-full border"
              />
              <span>{username}</span>
            </button>
            {dropdownOpen && (
              <div className="absolute right-0 mt-2 bg-white text-black shadow-lg rounded-md">
                {settingsLinks.map((link) => (
                  <NavLink
                    key={link.name}
                    to={link.path}
                    className="block px-4 py-2 hover:bg-gray-100"
                  >
                    {link.name}
                  </NavLink>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};

# components/layout/layout/Layout.css
.Layout {
    display: grid;
    grid-template-rows: auto 1fr auto; /* Ensure flexible row height */
    grid-template-columns: 1fr 3fr;
    height: 100vh; /* Ensure the layout spans the full viewport */
  }

.Layout > header {
    grid-column: 1 / span 2;
    grid-row: 1;
}

.Layout > footer {
    grid-column: 1 / span 2;
    grid-row: 4;
}

.Layout > aside:nth-child(1) {
    grid-column: 1;
    grid-row: 2;
}

.Layout > aside:nth-child(2) {
    grid-column: 1;
    grid-row: 3;
}


  
  .Layout > main {
    height: 100%; /* Inherit full height from the parent */
    overflow-y: auto; /* Allow scrolling for the content */
  }
  
  

.Layout > * {
    border: 1px dashed lightcoral;
}

# components/layout/layout/Layout.tsx
// components/layout/layout/Layout.tsx
import React, { useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import Folowers from "../folowers/Folowers";
import Followings from "../following/Following";
import Footer from "../footer/Footer";
import Header from "../header/Header";
import LoginPage from "../login/login";
import { AuthContext } from "../../auth/Auth";

// Utility function to check if the user is authenticated


export default function Layout() {
  // Redirect to /login if the user is not authenticated
  // if (!isAuthenticated()) {
  //   return <Navigate to="/login" replace />;
  // }

  const {jwt} = useContext(AuthContext)!;
const isAuthenticated: boolean = !!jwt;


  return (
    <div>
      {!isAuthenticated && (
        <>
          <LoginPage />
        </>
      )}

      {isAuthenticated && (
        <>
          <div className="grid grid-rows-[auto_1fr_auto] grid-cols-[1fr_3fr] h-screen">
            <header className="col-span-2 row-start-1 bg-gray-100 border border-gray-300">
              <Header />
            </header>

            <aside className="col-start-1 row-start-2 bg-white border border-gray-300 p-4 h-full grid grid-rows-2 gap-4">
              <div className="overflow-y-auto">
                <Followings />
              </div>
              <div className="overflow-y-auto">
                <Folowers />
              </div>
            </aside>

            <main className="col-start-2 row-start-2 row-span-2 bg-gray-50 border border-gray-300 p-4">
              <div className="h-full overflow-y-auto">
                <Outlet />
              </div>
            </main>

            <footer className="col-span-2 row-start-4 bg-gray-800 h-5 text-white text-center py-4">
              <Footer />
            </footer>
          </div>
        </>
      )}
    </div>
  );
}

# components/layout/login/login.tsx
import React, { useContext } from "react";
import { useNavigate } from "react-router-dom";
import auth from "../../../services/auth";
import { AuthContext } from "../../auth/Auth";

export default function LoginPage() {
  const navigate = useNavigate();

  const { newLogin } = useContext(AuthContext)!;

  const handleSubmit = async (event: { preventDefault: () => void; currentTarget: HTMLFormElement | undefined; }) => {
    event.preventDefault();
    const data = new FormData(event.currentTarget);
    const username = data.get("username");
    const password = data.get("password");

    getJwt(username, password);
  };
  async function getJwt(username, password) {
    try {
      const userJwt = await auth.login({ username, password });
      newLogin(userJwt)!;
      console.log(userJwt);
      document.cookie = `auth=${userJwt}; path=/; secure; SameSite=Strict`;
      navigate("/");
    } catch (error) {
      console.error("Login failed:", error);
    }
  }
  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100">
      <div className="w-full max-w-md p-6 bg-white shadow-md rounded-md">
        <h1 className="text-2xl font-bold text-center mb-6">Sign In</h1>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label
              htmlFor="username"
              className="block text-sm font-medium text-gray-700"
            >
              Username
            </label>
            <input
              id="username"
              name="username"
              type="text"
              required
              autoComplete="username"
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              defaultValue={"bob000"}
            />
          </div>
          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700"
            >
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              autoComplete="current-password"
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              defaultValue={"123456"}
            />
          </div>
          <button
            type="submit"
            className="w-full px-4 py-2 text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            Sign In
          </button>
          <div className="flex justify-between items-center text-sm">
            <a href="#" className="text-blue-500 hover:underline">
              Forgot password?
            </a>
            <a href="#" className="text-blue-500 hover:underline">
              Don't have an account? Sign Up
            </a>
          </div>
        </form>
      </div>
    </div>
  );
}

# components/layout/logout/logout.tsx
import React, { useEffect } from 'react';
import { Container, Typography, Box, Button } from '@mui/material';
import Cookies from 'js-cookie';

const LogoutPage = () => {
    useEffect(() => {
        // Delete the 'auth' cookie
        Cookies.remove('auth');

        // Redirect to the home page after a delay (optional)
        const timer = setTimeout(() => {
            window.location.href = '/';
        }, 3000);

        return () => clearTimeout(timer);
    }, []);

    return (
        <Container
            maxWidth={false}
            disableGutters
            style={{
                position: 'fixed',
                top: 0,
                left: 0,
                width: '100vw',
                height: '100vh',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                backgroundColor: '#f5f5f5',
                zIndex: 9999,
                textAlign: 'center',
            }}
        >
            <Box
                sx={{
                    padding: 4,
                    borderRadius: 2,
                    boxShadow: 3,
                    backgroundColor: 'white',
                }}
            >
                <Typography variant="h4" gutterBottom>
                    Thank You!
                </Typography>
                <Typography variant="body1" gutterBottom>
                    Thanks for using our social media software. We hope to see you again soon!
                </Typography>
                <Button
                    variant="contained"
                    color="primary"
                    onClick={() => { window.location.href = '/'; }}
                    sx={{ mt: 2 }}
                >
                    Go to Homepage
                </Button>
            </Box>
        </Container>
    );
};

export default LogoutPage;

# components/layout/not-found/NotFound.css

# components/layout/not-found/NotFound.tsx
import './NotFound.css'

export default function NotFound(): JSX.Element {
    return (
        <div className='NotFound'>
            <h1>404</h1>
            <p>Page not found</p>
            <p>Noop is an afghan hound</p>
        </div>
    )
}
# components/layout/routing/Routing.tsx
// components/layout/routing/Routing.tsx
import { Routes, Route } from "react-router-dom";
import Layout from "../layout/Layout";
import Profile from "../../posts/profile/Profile";
import Feed from "../../posts/feed/Feed";
import LoginPage from "../login/login";
import LogoutPage from "../logout/logout";
import NotFound from "../not-found/NotFound";

export default function Routing(): JSX.Element {
  return (
    <Routes>
      {/* Public routes */}
      <Route path="/login" element={<LoginPage />} />
      <Route path="/logout" element={<LogoutPage />} />

      {/* Protected routes inside Layout */}
      <Route path="/" element={<Layout />}>
        <Route path="/profile" element={<Profile />} />
        <Route path="/feed" element={<Feed />} />
        <Route path="*" element={<NotFound />} />
      </Route>
    </Routes>
  );
}

# components/posts/feed/Feed.css

# components/posts/feed/Feed.tsx
// Feed.tsx
import React, { useEffect, useState } from 'react';
import feed from '../../../services/Feed';
import profileService from '../../../services/Profile';
import FeedPost from './FeedPost';
import Loading from '../../common/Loading';
import PostModel from '../../../models/posts/Post';

export default function Feed() {
  const [posts, setPosts] = useState<PostModel[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchData = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await feed.getFeed();
      // Sort posts by date (newest first)
      const sortedPosts = data.sort((a, b) => 
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      );
      setPosts(sortedPosts);
    } catch (err: any) {
      setError(err.message || 'An error occurred while fetching the feed.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleAddComment = async (postId: string, comment: string) => {
    try {
      const newComment = await profileService.addComment(postId, comment);
      // Update the posts state with the new comment
      setPosts(currentPosts => 
        currentPosts.map(post => {
          if (post.id === postId) {
            return {
              ...post,
              comments: [...(post.comments || []), newComment].sort(
                (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
              )
            };
          }
          return post;
        })
      );
    } catch (error) {
      console.error('Failed to add comment:', error);
      throw error;
    }
  };

  if (loading) {
    return <Loading isLoading={true} />;
  }

  if (error) {
    return (
      <div className="p-4 text-center">
        <div className="text-red-500 mb-4">{error}</div>
        <button
          onClick={fetchData}
          className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600"
        >
          Try Again
        </button>
      </div>
    );
  }

  return (
    <div className="max-w-3xl mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6 text-gray-900">Your Feed</h1>
      <div className="space-y-6">
        {posts.length > 0 ? (
          posts.map(post => (
            <FeedPost
              key={post.id}
              post={post}
              onAddComment={handleAddComment}
            />
          ))
        ) : (
          <div className="text-center text-gray-500 py-8">
            No posts to show. Follow some users to see their posts here!
          </div>
        )}
      </div>
    </div>
  );
}
# components/posts/feed/FeedPost.tsx
import React, { useState } from 'react';

interface FeedPostProps {
  post: {
    id: string;
    title: string;
    body: string;
    createdAt: string;
    user: {
      id: string;
      name: string;
    };
    comments: Array<{
      id: string;
      body: string;
      createdAt: string;
      user: {
        id: string;
        name: string;
      };
    }>;
  };
  onAddComment: (postId: string, comment: string) => Promise<void>;
}

const FeedPost: React.FC<FeedPostProps> = ({ post, onAddComment }) => {
  const [showComments, setShowComments] = useState(false);
  const [newComment, setNewComment] = useState('');
  const [isAddingComment, setIsAddingComment] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 7) {
      return date.toLocaleDateString();
    } else if (days > 0) {
      return `${days}d ago`;
    } else if (hours > 0) {
      return `${hours}h ago`;
    } else if (minutes > 0) {
      return `${minutes}m ago`;
    } else {
      return 'Just now';
    }
  };

  const handleAddComment = async () => {
    if (!newComment.trim()) return;
    
    setIsAddingComment(true);
    setError(null);
    try {
      await onAddComment(post.id, newComment);
      setNewComment('');
    } catch (err) {
      setError('Failed to add comment. Please try again.');
    } finally {
      setIsAddingComment(false);
    }
  };

  // Sort comments by date (oldest first)
  const sortedComments = [...(post.comments || [])].sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
  );

  return (
    <div className="mb-6 overflow-hidden bg-white rounded-lg shadow-lg">
      {/* Post Header */}
      <div className="flex items-start space-x-4 p-4 border-b border-gray-100">
        <div className="flex-shrink-0">
          <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white text-lg font-semibold shadow-lg">
            {post.user?.name?.[0]?.toUpperCase() || '?'}
          </div>
        </div>
        
        <div className="flex-grow">
          <div className="flex items-baseline justify-between">
            <h3 className="font-semibold text-gray-900">
              {post.user?.name || 'Anonymous'}
            </h3>
            <span className="text-sm text-gray-500">
              {formatDate(post.createdAt)}
            </span>
          </div>
          
          <h4 className="text-lg font-medium text-gray-900 mt-2">
            {post.title}
          </h4>
        </div>
      </div>

      {/* Post Content */}
      <div className="p-4">
        <div 
          className="prose max-w-none"
          dangerouslySetInnerHTML={{ __html: post.body }}
        />
      </div>

      {/* Post Actions */}
      <div className="px-4 py-3 border-t border-gray-100 bg-gray-50">
        <button
          onClick={() => setShowComments(!showComments)}
          className="inline-flex items-center space-x-2 text-gray-600 hover:text-gray-900 transition-colors"
        >
          <span className="text-xl">ðŸ’¬</span>
          <span className="text-sm font-medium">
            {post.comments?.length || 0} Comments
          </span>
        </button>
      </div>

      {/* Comments Section */}
      {showComments && (
        <div className="border-t border-gray-100 bg-gray-50">
          {/* Existing Comments */}
          <div className="divide-y divide-gray-100">
            {sortedComments.map((comment) => (
              <div key={comment.id} className="p-4">
                <div className="flex items-start space-x-3">
                  <div className="flex-shrink-0">
                    <div className="w-8 h-8 bg-gradient-to-br from-purple-500 to-pink-500 rounded-full flex items-center justify-center text-white text-sm font-semibold">
                      {comment.user?.name?.[0]?.toUpperCase() || '?'}
                    </div>
                  </div>
                  <div className="flex-grow">
                    <div className="flex items-center justify-between">
                      <span className="font-medium text-gray-900">
                        {comment.user?.name || 'Anonymous'}
                      </span>
                      <span className="text-xs text-gray-500">
                        {formatDate(comment.createdAt)}
                      </span>
                    </div>
                    <div 
                      className="mt-1 text-gray-700 text-sm"
                      dangerouslySetInnerHTML={{ __html: comment.body }}
                    />
                  </div>
                </div>
              </div>
            ))}
            
            {sortedComments.length === 0 && (
              <div className="p-4 text-center text-gray-500">
                No comments yet. Be the first to comment!
              </div>
            )}
          </div>

          {/* Add Comment Form */}
          <div className="p-4 bg-white border-t border-gray-100">
            <textarea
              value={newComment}
              onChange={(e) => setNewComment(e.target.value)}
              placeholder="Write a comment..."
              className="w-full min-h-[100px] p-3 border border-gray-200 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-y"
              maxLength={1000}
            />
            {error && (
              <div className="mt-2 text-sm text-red-500">
                {error}
              </div>
            )}
            <div className="mt-3 flex justify-between items-center">
              <span className="text-xs text-gray-500">
                {1000 - newComment.length} characters remaining
              </span>
              <button
                onClick={handleAddComment}
                disabled={isAddingComment || !newComment.trim()}
                className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
              >
                {isAddingComment ? (
                  <span className="flex items-center space-x-2">
                    <span className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                    <span>Posting...</span>
                  </span>
                ) : (
                  'Post Comment'
                )}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default FeedPost;
# components/posts/new/NewForm.css

# components/posts/new/NewPost.tsx
// components/posts/new/NewPost.tsx
import React, { useState } from "react";
import { useForm, SubmitHandler } from "react-hook-form";
import PostDraft from "../../../models/posts/PostDraft";
import TinyEditor from "../../common/TinyEditor";
import Loading from "../../common/Loading";

interface NewPostProps {
  onAddPost: (newPost: PostDraft) => void;
}

const MIN_TITLE_LENGTH = 10;
const MIN_BODY_LENGTH = 20;

export default function NewPost({ onAddPost }: NewPostProps) {
  const { register, handleSubmit, reset, setValue, formState: { errors } } = useForm<PostDraft>();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [bodyContent, setBodyContent] = useState("");
  const [bodyError, setBodyError] = useState<string | null>(null);
  const [showForm, setShowForm] = useState(false);

  const handleEditorChange = (content: string) => {
    setBodyContent(content);
    setValue("body", content);
    // Clear body error when user starts typing
    setBodyError(null);
  };

  const validateBody = (content: string) => {
    // Strip HTML tags for length validation
    const stripHtml = (html: string) => {
      const tmp = document.createElement("DIV");
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    };

    const strippedBody = stripHtml(content).trim();
    
    if (!strippedBody) {
      return "Body content is required";
    }
    
    if (strippedBody.length < MIN_BODY_LENGTH) {
      return `Body must be at least ${MIN_BODY_LENGTH} characters long (currently: ${strippedBody.length})`;
    }

    return null;
  };

  const onSubmit: SubmitHandler<PostDraft> = async (data) => {
    const bodyValidationError = validateBody(bodyContent);
    
    if (bodyValidationError) {
      setBodyError(bodyValidationError);
      return;
    }

    setLoading(true);
    setError(null);
    setBodyError(null);

    try {
      await onAddPost({ ...data, body: bodyContent });
      reset();
      setBodyContent("");
      setShowForm(false);
    } catch (error: any) {
      setError(error.message || "Failed to add post.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow-md mb-6">
      <button
        onClick={() => setShowForm(!showForm)}
        className="w-full p-4 text-left flex justify-between items-center hover:bg-gray-50"
      >
        <span className="text-lg font-semibold">
          {showForm ? "Close New Post" : "Create New Post"}
        </span>
        <span className="text-2xl">{showForm ? "âˆ’" : "+"}</span>
      </button>

      {showForm && (
        <form onSubmit={handleSubmit(onSubmit)} className="p-6 border-t">
          <Loading isLoading={loading} error={error} />
          
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Title *
            </label>
            <input
              type="text"
              className={`w-full p-2 border rounded-md ${
                errors.title ? "border-red-500" : "border-gray-300"
              }`}
              {...register("title", { 
                required: "Title is required",
                minLength: {
                  value: MIN_TITLE_LENGTH,
                  message: `Title must be at least ${MIN_TITLE_LENGTH} characters`
                }
              })}
              placeholder={`Enter a title (minimum ${MIN_TITLE_LENGTH} characters)`}
            />
            {errors.title && (
              <p className="mt-1 text-sm text-red-500">{errors.title.message}</p>
            )}
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Body *
            </label>
            <TinyEditor
              value={bodyContent}
              onChange={handleEditorChange}
              placeholder={`Write your post content (minimum ${MIN_BODY_LENGTH} characters)...`}
            />
            {bodyError && (
              <p className="mt-1 text-sm text-red-500">{bodyError}</p>
            )}
          </div>

          <div className="flex justify-end gap-4">
            <button
              type="button"
              onClick={() => {
                reset();
                setBodyContent("");
                setBodyError(null);
                setError(null);
                setShowForm(false);
              }}
              className="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-400"
            >
              {loading ? "Creating..." : "Create Post"}
            </button>
          </div>
        </form>
      )}
    </div>
  );
}
# components/posts/post/Post.css
.posts-inner-container {
    transition: opacity 2.5s ease-in-out;
    opacity: 1;
  }
  
  .posts-inner-container.fade-out {
    opacity: 0;
    pointer-events: none; /* Optional: Prevent interactions during fade-out */
  }
  
# components/posts/post/Post.tsx
import React, { useState } from "react";
import { useAppDispatch } from "../../../redux/hooks";
import { deleteProfilePost, updateProfilePost } from "../../../redux/profileSlice";
import PostModel from "../../../models/posts/Post";
import PostsUi from "./PostUi";

interface PostProps {
  post: PostModel;
}

export default function Post({ post }: PostProps): JSX.Element {
  const dispatch = useAppDispatch();

  const [isEditing, setIsEditing] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [newTitle, setNewTitle] = useState(post.title);
  const [newBody, setNewBody] = useState(post.body);

  const profilePictureUrl = "https://cdn.ozari.co.il/beery/noop.jpeg"; // Fixed profile picture URL

  // Handle delete
  const handleDelete = async () => {
    await dispatch(deleteProfilePost(post.id));
    setIsDeleteDialogOpen(false);
  };

  // Handle update
  const handleUpdate = async () => {
    if (newTitle.trim() && newBody.trim()) {
      await dispatch(updateProfilePost({ id: post.id, updatedPost: { title: newTitle, body: newBody } }));
      setIsEditing(false);
    }
  };

  return (
    <PostsUi
      post={post}
      profilePictureUrl={profilePictureUrl}
      isEditing={isEditing}
      isDeleteDialogOpen={isDeleteDialogOpen}
      setIsEditing={setIsEditing}
      setIsDeleteDialogOpen={setIsDeleteDialogOpen}
      newTitle={newTitle}
      newBody={newBody}
      setNewTitle={setNewTitle}
      setNewBody={setNewBody}
      onDelete={handleDelete}
      onUpdate={handleUpdate}
    />
  );
}

# components/posts/post/PostsUi.css
.post-card {
    margin: 16px;
    padding: 16px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .post-header {
    display: flex;
    align-items: center;
  }
  
  .profile-pic {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    margin-right: 8px;
  }
  
  .post-title {
    font-size: 1.5rem;
    font-weight: bold;
  }
  
  .post-body {
    margin-top: 16px;
  }
  
  .comment-item {
    margin-bottom: 12px;
  }
  
  .submit-comment {
    margin-top: 16px;
  }
  
# components/posts/post/PostUi.tsx
// components/posts/post/PostUi.tsx
import React, { useState } from "react";
import { useAppDispatch } from "../../../redux/hooks";
import { addCommentToPost } from "../../../redux/profileSlice";
import TinyEditor from "../../common/TinyEditor";
import PostModel from "../../../models/posts/Post";

interface PostsUiProps {
  post: PostModel;
  profilePictureUrl: string;
  isEditing: boolean;
  isDeleteDialogOpen: boolean;
  setIsEditing: (value: boolean) => void;
  setIsDeleteDialogOpen: (value: boolean) => void;
  newTitle: string;
  newBody: string;
  setNewTitle: (value: string) => void;
  setNewBody: (value: string) => void;
  onDelete: () => Promise<void>;
  onUpdate: () => Promise<void>;
}

const MIN_COMMENT_LENGTH = 20;

export default function PostsUi({
  post,
  profilePictureUrl,
  isEditing,
  isDeleteDialogOpen,
  setIsEditing,
  setIsDeleteDialogOpen,
  newTitle,
  newBody,
  setNewTitle,
  setNewBody,
  onDelete,
  onUpdate,
}: PostsUiProps): JSX.Element {
  const dispatch = useAppDispatch();
  const [showComments, setShowComments] = useState(false);
  const [newComment, setNewComment] = useState("");
  const [commentError, setCommentError] = useState<string | null>(null);

  const validateComment = (comment: string) => {
    // Strip HTML tags for length validation
    const stripHtml = (html: string) => {
      const tmp = document.createElement("DIV");
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    };

    const strippedComment = stripHtml(comment);
    return strippedComment.length >= MIN_COMMENT_LENGTH;
  };

  const handleAddComment = async () => {
    setCommentError(null);

    if (!validateComment(newComment)) {
      setCommentError(`Comment must be at least ${MIN_COMMENT_LENGTH} characters long`);
      return;
    }

    try {
      await dispatch(addCommentToPost({
        postId: post.id,
        body: newComment
      })).unwrap();
      setNewComment("");
    } catch (error) {
      console.error("Failed to add comment:", error);
      setCommentError("Failed to add comment. Please try again.");
    }
  };

  const handleUpdate = async () => {
    try {
      await onUpdate();
    } catch (error) {
      console.error("Failed to update post:", error);
    }
  };

  return (
    <div className="border rounded-lg shadow-lg bg-white p-6 mb-6">
      {/* Header Section */}
      <div className="flex items-center justify-between">
        <div className="flex items-center">
          <img
            src={profilePictureUrl}
            alt="Profile"
            className="w-10 h-10 rounded-full mr-4"
          />
          <div>
            <h2 className="text-lg font-semibold">{post.user?.name || "Anonymous"}</h2>
            <p className="text-sm text-gray-500">{new Date(post.createdAt).toLocaleString()}</p>
          </div>
        </div>
        <div className="flex items-center space-x-4">
          <button
            onClick={() => setShowComments(true)}
            className="p-2 rounded-full bg-blue-500 hover:bg-blue-600 text-white"
            title="Comments"
          >
            ðŸ’¬ {post.comments?.length || 0}
          </button>
          <button
            onClick={() => setIsEditing(!isEditing)}
            className={`p-2 rounded-full ${
              isEditing ? "bg-gray-400 hover:bg-gray-500" : "bg-green-500 hover:bg-green-600"
            } text-white`}
            title="Edit"
          >
            âœï¸
          </button>
          <button
            onClick={() => setIsDeleteDialogOpen(true)}
            className="p-2 rounded-full bg-red-500 hover:bg-red-600 text-white"
            title="Delete"
          >
            ðŸ—‘ï¸
          </button>
        </div>
      </div>

      {/* Content Section */}
      {!isEditing ? (
        <div className="mt-4">
          <h3 className="text-xl font-bold">{post.title}</h3>
          <div
            className="mt-2 text-gray-700"
            dangerouslySetInnerHTML={{ __html: post.body }}
          />
        </div>
      ) : (
        <div className="mt-4">
          <input
            type="text"
            value={newTitle}
            onChange={(e) => setNewTitle(e.target.value)}
            className="w-full p-2 border rounded-md mb-4"
            placeholder="Enter title"
            minLength={10}
          />
          <TinyEditor
            value={newBody}
            onChange={setNewBody}
            placeholder="Enter content..."
          />
          <div className="mt-4 flex justify-end space-x-4">
            <button
              onClick={handleUpdate}
              className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md"
            >
              Save
            </button>
            <button
              onClick={() => setIsEditing(false)}
              className="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-700 rounded-md"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Comments Modal */}
      {showComments && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
          <div className="bg-white w-11/12 md:max-w-2xl p-6 rounded-lg shadow-lg overflow-y-auto max-h-screen">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-bold">Comments ({post.comments?.length || 0})</h3>
              <button
                onClick={() => setShowComments(false)}
                className="text-gray-500 hover:text-gray-700"
              >
                âœ•
              </button>
            </div>

            <div className="space-y-4 mb-6">
              {post.comments?.map((comment) => (
                <div key={comment.id} className="border-b pb-4">
                  <div className="flex items-center mb-2">
                    <div className="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white text-sm mr-2">
                      {comment.user?.name?.[0] || 'A'}
                    </div>
                    <div>
                      <p className="font-semibold">{comment.user?.name || "Anonymous"}</p>
                      <p className="text-xs text-gray-500">
                        {new Date(comment.createdAt).toLocaleString()}
                      </p>
                    </div>
                  </div>
                  <div
                    className="text-gray-700 pl-10"
                    dangerouslySetInnerHTML={{ __html: comment.body }}
                  />
                </div>
              ))}
              {post.comments?.length === 0 && (
                <p className="text-gray-500 text-center">No comments yet</p>
              )}
            </div>

            <div className="border-t pt-4">
              <div className="mb-4">
                <TinyEditor
                  value={newComment}
                  onChange={setNewComment}
                  placeholder="Add a comment..."
                />
                <p className="mt-1 text-sm text-gray-500">
                  Minimum {MIN_COMMENT_LENGTH} characters required
                </p>
                {commentError && (
                  <p className="mt-1 text-sm text-red-500">{commentError}</p>
                )}
              </div>
              <div className="flex justify-end gap-4">
                <button
                  onClick={() => setShowComments(false)}
                  className="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-700 rounded-md"
                >
                  Cancel
                </button>
                <button
                  onClick={handleAddComment}
                  className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md"
                  disabled={!newComment.trim()}
                >
                  Add Comment
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Delete Confirmation Dialog */}
      {isDeleteDialogOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-lg">
            <h3 className="text-lg font-bold mb-4">Delete Post</h3>
            <p className="mb-4">Are you sure you want to delete this post?</p>
            <div className="flex justify-end space-x-4">
              <button
                onClick={() => setIsDeleteDialogOpen(false)}
                className="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-700 rounded-md"
              >
                Cancel
              </button>
              <button
                onClick={onDelete}
                className="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-md"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
# components/posts/profile/Profile.css
.posts-container {
    flex-grow: 1; /* Fill available space */
    height: 100%; /* Allow the container to take up the full height */
    overflow-y: auto;
    padding: 16px;
  }
  
  
  .posts-container::-webkit-scrollbar {
    width: 6px;
  }
  
  .posts-container::-webkit-scrollbar-thumb {
    background-color: #888;
    border-radius: 3px;
  }
  
# components/posts/profile/Profile.tsx
// components/posts/profile/Profile.tsx
import React, { useEffect } from "react";
import { useAppDispatch, useAppSelector } from "../../../redux/hooks";
import { fetchProfilePosts, addProfilePost } from "../../../redux/profileSlice";
import NewPost from "../new/NewPost";
import Post from "../post/Post";
import Loading from "../../common/Loading";
import useTitle from "../../../hooks/useTitle";
import "./Profile.css";

export default function Profile() {
  useTitle("Profile");
  const dispatch = useAppDispatch();
  const { posts, loading, error } = useAppSelector((state) => {
    console.log("Current Redux State:", state); // Debug log
    return state.profile;
  });

  useEffect(() => {
    const loadPosts = async () => {
      try {
        const resultAction = await dispatch(fetchProfilePosts()).unwrap();
        console.log("Fetched posts:", resultAction); // Debug log
      } catch (err) {
        console.error("Failed to fetch posts:", err); // Debug log
      }
    };
    loadPosts();
  }, [dispatch]);

  const handleAddPost = async (newPost) => {
    try {
      const resultAction = await dispatch(addProfilePost(newPost)).unwrap();
      console.log("Added new post:", resultAction); // Debug log
    } catch (err) {
      console.error("Failed to add post:", err); // Debug log
    }
  };

  // Debug log for render
  console.log("Current posts:", posts);

  if (loading) {
    return <Loading isLoading={true} />;
  }

  if (error) {
    return <div className="text-red-500">Error: {error}</div>;
  }

  return (
    <div className="flex flex-col h-full bg-gray-100 p-4">
      <NewPost onAddPost={handleAddPost} />
      <div className="posts-container flex-grow mt-6">
        {Array.isArray(posts) && posts.length > 0 ? (
          posts.map((post) => (
            <Post key={post.id} post={post} />
          ))
        ) : (
          <div className="text-center text-gray-500 mt-4">
            No posts found. Create your first post above!
          </div>
        )}
      </div>
    </div>
  );
}
# hooks/useService.ts
import axios from "axios";
import { useContext, useMemo } from "react";
import { AuthContext } from "../components/auth/Auth";

export default function useService<T>(ServiceClass: new (axiosInstance: any) => T): T {
  const { jwt } = useContext(AuthContext)!;

  const axiosInstance = useMemo(() => {
    return axios.create({
      baseURL: import.meta.env.VITE_REST_SERVER_URL,
      headers: {
        Authorization: `Bearer ${jwt}`,
      },
    });
  }, [jwt]);

  return useMemo(() => new ServiceClass(axiosInstance), [ServiceClass, axiosInstance]);
}

# hooks/useTitle.ts
import { useEffect } from "react";

export default function useTitle(title: string) {
    useEffect(() => {
        document.title = title;
    }, [title]);
}
# hooks/useUsername.ts
import { jwtDecode } from "jwt-decode";
import { useContext, useMemo } from "react";
import { AuthContext } from "../components/auth/Auth";
import User from "../models/users/Users";

export default function useUsername() {
    const { jwt } = useContext(AuthContext)!;
    // const {name} = jwtDecode<User>(jwt);
  
  const name = useMemo(() => {
    const {name} = jwtDecode<User>(jwt);
    return name;
  }, [jwt]);
    
        return name;
}

# index.css
@tailwind base;
@tailwind components;
@tailwind utilities;
/* Base Scrollbar Styles */
* {
    @apply scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200;
  }
  
  /* Thumb Hover Effect */
  *:hover {
    @apply scrollbar-thumb-gray-500;
  }
 
# input.css

# main.tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './assets/output.css'
import App from './components/app/App.tsx'
import * as Sentry from "@sentry/react";



// Sentry.init({
//   dsn: "https://106544dd7f0888e8cf6de5f307cd654f@o4508091701592065.ingest.us.sentry.io/4508629353234432",
//   integrations: [
//     Sentry.browserTracingIntegration(),
//   ],
//   // Tracing
//   tracesSampleRate: 1.0, //  Capture 100% of the transactions
//   // Set 'tracePropagationTargets' to control for which URLs distributed tracing should be enabled
//   tracePropagationTargets: ["localhost", /^https:\/\/jb\.noop\.co\.il/],
// });

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

# models/comment/CommentDraft.ts
export default interface CommentDraft {
    postId: string;
    body: string;
}
# models/comment/Comments.ts
import User from "../users/Users";
import CommentDraft from "./CommentDraft";
export default interface Comment extends CommentDraft {
    id: string;
    userId: string;
    createdAt: string;
    updatedAt: string;
    user: User;
}

# models/login/User.ts

# models/posts/Post.ts
import Comment from "../comment/Comments";
import User from "../users/Users";
import PostDraft from "./PostDraft";
export default interface Post extends PostDraft {
    id: string;
    userId: string;

    imageUrl: string;
    createdAt: string;
    updatedAt: string;
    comments: Comment[];
    user: User;
}
# models/posts/PostDraft.ts
export default interface PostDraft {
    title: string;
    body: string;
}
# models/userFollower/UserFollower.ts
 export default interface userFollower {
    id:string;
    name:string
    username:string;
    password:string;
    created_at:string;
    updated_at:string;

 }
# models/users/Login.ts
export default interface Login {
    username: string;
    password: string;
}
# models/users/Users.ts
import Login from "./Login";

export default interface User extends Login {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
}
# redux/followersSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import User from '../models/users/Users';

interface FollowersState {
  followers: User[];
}

const initialState: FollowersState = {
  followers: [],
};

export const followersSlice = createSlice({
  name: 'followers',
  initialState,
  reducers: {
    init: (state, action: PayloadAction<User[]>) => {
      state.followers = action.payload;
    },
    unfollow: (state, action: PayloadAction<string>) => {
      state.followers = state.followers.filter(user => user.id !== action.payload);
    },
    follow: (state, action: PayloadAction<User>) => {
      state.followers.push(action.payload);
    },
  },
});

export const { init, unfollow, follow } = followersSlice.actions;

export default followersSlice.reducer;

# redux/followingSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import User from '../models/users/Users';

interface FollowingState {
    following: User[];
}

const initialState: FollowingState = {
    following: []
}

export const followingSlice = createSlice({
    name: 'following',
    initialState,
    reducers: {
        init: (state, action: PayloadAction<User[]>) => {
        state.following = action.payload;
        }, 
        unfollow: (state, action: PayloadAction<string>) => {
            state.following = state.following.filter(user => user.id !== action.payload);
        },
        follow: (state, action: PayloadAction<User>) => {
            state.following.push(action.payload);
        }
    }

})

export const { init, unfollow, follow } = followingSlice.actions

export default followingSlice.reducer
# redux/hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

# redux/profileSlice.ts
// redux/profileSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import profileService from "../services/Profile";
import Post from "../models/posts/Post";
import PostDraft from "../models/posts/PostDraft";

interface ProfileState {
  posts: Post[];
  loading: boolean;
  error: string | null;
}

const initialState: ProfileState = {
  posts: [],
  loading: false,
  error: null,
};

// Fetch posts
export const fetchProfilePosts = createAsyncThunk(
  "profile/fetchPosts",
  async (_, { rejectWithValue }) => {
    try {
      return await profileService.getProfile();
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to fetch posts.");
    }
  }
);

// Add post
export const addProfilePost = createAsyncThunk(
  "profile/addPost",
  async (newPost: PostDraft, { rejectWithValue }) => {
    try {
      return await profileService.addPost(newPost);
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to add post.");
    }
  }
);

// Update post
export const updateProfilePost = createAsyncThunk(
  "profile/updatePost",
  async ({ id, updatedPost }: { id: string; updatedPost: PostDraft }, { rejectWithValue }) => {
    try {
      const response = await profileService.updatePost(id, updatedPost);
      return { id, updatedPost: response };
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to update post.");
    }
  }
);

// Delete post
export const deleteProfilePost = createAsyncThunk(
  "profile/deletePost",
  async (id: string, { rejectWithValue }) => {
    try {
      await profileService.removePost(id);
      return id;
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to delete post.");
    }
  }
);

// Add comment
export const addCommentToPost = createAsyncThunk(
  "profile/addComment",
  async ({ postId, body }: { postId: string; body: string }, { rejectWithValue }) => {
    try {
      const newComment = await profileService.addComment(postId, body);
      return { postId, comment: newComment };
    } catch (error: any) {
      return rejectWithValue(error.message || "Failed to add comment.");
    }
  }
);

const profileSlice = createSlice({
  name: "profile",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Fetch posts
      .addCase(fetchProfilePosts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProfilePosts.fulfilled, (state, action: PayloadAction<Post[]>) => {
        state.posts = action.payload;
        state.loading = false;
      })
      .addCase(fetchProfilePosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Add post
      .addCase(addProfilePost.pending, (state) => {
        state.loading = true;
      })
      .addCase(addProfilePost.fulfilled, (state, action: PayloadAction<Post>) => {
        state.posts = [...state.posts , action.payload];
        state.loading = false;
      })
      .addCase(addProfilePost.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Update post
      .addCase(updateProfilePost.pending, (state) => {
        state.loading = true;
      })
      .addCase(updateProfilePost.fulfilled, (state, action) => {
        const { id, updatedPost } = action.payload;
        const index = state.posts.findIndex(post => post.id === id);
        if (index !== -1) {
          state.posts[index] = { ...state.posts[index], ...updatedPost };
        }
        state.loading = false;
      })
      .addCase(updateProfilePost.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Delete post
      .addCase(deleteProfilePost.pending, (state) => {
        state.loading = true;
      })
      .addCase(deleteProfilePost.fulfilled, (state, action) => {
        state.posts = state.posts.filter(post => post.id !== action.payload);
        state.loading = false;
      })
      .addCase(deleteProfilePost.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Add comment
      .addCase(addCommentToPost.fulfilled, (state, action) => {
        const { postId, comment } = action.payload;
        const post = state.posts.find(p => p.id === postId);
        if (post) {
          if (!post.comments) {
            post.comments = [];
          }
          post.comments.push(comment);
        }
      })
      .addCase(addCommentToPost.rejected, (state, action) => {
        state.error = action.payload as string;
      });
  },
});

export default profileSlice.reducer;
# redux/slices/authSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface AuthState {
  isAuthenticated: boolean;
}

const initialState: AuthState = {
  isAuthenticated: false,
};

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    login: (state) => {
      state.isAuthenticated = true;
    },
    logout: (state) => {
      state.isAuthenticated = false;
    },
  },
});

export const { login, logout } = authSlice.actions;
export default authSlice.reducer;

# redux/slices/followersSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import User from '../../models/users/Users';

interface FollowersState {
  followers: User[];
}

const initialState: FollowersState = {
  followers: [],
};

const followersSlice = createSlice({
  name: 'followers',
  initialState,
  reducers: {
    init: (state, action: PayloadAction<User[]>) => ({
      ...state,
      followers: action.payload,
    }),
    unfollow: (state, action: PayloadAction<string>) => ({
      ...state,
      followers: state.followers.filter(user => user.id !== action.payload),
    }),
    follow: (state, action: PayloadAction<User>) => ({
      ...state,
      followers: [...state.followers, action.payload],
    }),
  },
});

export const { init, unfollow, follow } = followersSlice.actions;
export default followersSlice.reducer;

# redux/slices/followingSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import User from '../../models/users/Users';

interface FollowingState {
  following: User[];
}

const initialState: FollowingState = {
  following: [],
};

const followingSlice = createSlice({
  name: 'following',
  initialState,
  reducers: {
    init: (state, action: PayloadAction<User[]>) => ({
      ...state,
      following: action.payload,
    }),
    unfollow: (state, action: PayloadAction<string>) => ({
      ...state,
      following: state.following.filter(user => user.id !== action.payload),
    }),
    follow: (state, action: PayloadAction<User>) => ({
      ...state,
      following: [...state.following, action.payload],
    }),
  },
});

export const { init, unfollow, follow } = followingSlice.actions;
export default followingSlice.reducer;

# redux/slices/profileSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import Post from '../../models/posts/Post';
import PostDraft from '../../models/posts/PostDraft';

interface ProfileState {
  posts: Post[];
  loading: boolean;
  error: string | null;
}

const initialState: ProfileState = {
  posts: [],
  loading: false,
  error: null,
};

const profileSlice = createSlice({
  name: 'profile',
  initialState,
  reducers: {
    fetchStart: (state) => ({
      ...state,
      loading: true,
      error: null,
    }),
    fetchSuccess: (state, action: PayloadAction<Post[]>) => ({
      ...state,
      posts: action.payload,
      loading: false,
    }),
    fetchFailure: (state, action: PayloadAction<string>) => ({
      ...state,
      loading: false,
      error: action.payload,
    }),
    addPost: (state, action: PayloadAction<Post>) => ({
      ...state,
      posts: [...state.posts, action.payload],
    }),
    updatePost: (state, action: PayloadAction<{ id: string; updatedPost: Post }>) => ({
      ...state,
      posts: state.posts.map(post =>
        post.id === action.payload.id ? { ...post, ...action.payload.updatedPost } : post
      ),
    }),
    deletePost: (state, action: PayloadAction<string>) => ({
      ...state,
      posts: state.posts.filter(post => post.id !== action.payload),
    }),
  },
});

export const {
  fetchStart,
  fetchSuccess,
  fetchFailure,
  addPost,
  updatePost,
  deletePost,
} = profileSlice.actions;
export default profileSlice.reducer;

# redux/store.ts
import { configureStore } from "@reduxjs/toolkit";
import followingSlice from "./followingSlice";
import followersSlice from "./followersSlice";
import profileSlice from "./profileSlice";

const store = configureStore({
  reducer: {
    following: followingSlice,
    followers: followersSlice,
    profile: profileSlice, // Add the profile slice here
  },
});

export default store;

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

# redux/thunks/profileThunks.ts
import { AppDispatch } from '../store';
import profileService from '../../services/Profile';
import {
  fetchStart,
  fetchSuccess,
  fetchFailure,
  addPost,
  updatePost,
  deletePost,
} from '../slices/profileSlice';
import PostDraft from '../../models/posts/PostDraft';

export const fetchProfilePosts = () => async (dispatch: AppDispatch) => {
  dispatch(fetchStart());
  try {
    const posts = await profileService.getProfile();
    dispatch(fetchSuccess(posts));
  } catch (error) {
    dispatch(fetchFailure(error.message || 'Failed to fetch posts.'));
  }
};

export const addProfilePost = (newPost: PostDraft) => async (dispatch: AppDispatch) => {
  try {
    const post = await profileService.addPost(newPost);
    dispatch(addPost(post));
  } catch (error) {
    console.error(error);
  }
};

# services/addComment.ts
import axios from "axios";
import CommentDraft from "../models/comment/CommentDraft";
import Comment from "../models/comment/Comments";


export default async function InsertComment(commentData: CommentDraft): Promise<Comment> {
  const jsonData = { body: commentData.body };
  try {
    const response = await axios.post(
      `${import.meta.env.VITE_REST_SERVER_URL}/comments/${commentData.postId}`,
      jsonData,
      { headers: { "Content-Type": "application/json" } }
    );
    console.log("Comment added successfully:", response.data);
    return response.data as Comment;
  } catch (error) {
    console.error("Error adding comment:", error);
    throw error; // Ensure the caller knows there was a failure
  }

}

# services/auth-aware/AuthAware.ts
import { AxiosInstance } from "axios";

export default abstract class AuthAware {
    constructor(public axiosInstance: AxiosInstance) {
        
    }
}
# services/auth-aware/FollowersService.ts
import axios from "axios";
import User from "../../models/users/Users";

class FollowerService {
  async getFollowers(): Promise<User[]> {
    console.log("Fetching followers...");
    const response = await axios.get<User[]>(`${import.meta.env.VITE_REST_SERVER_URL}/follows/followers`);
    return response.data;
  }

  async followUser(id: string) {
    console.log(`Following user with ID: ${id}`);
    const result = await axios.post(`${import.meta.env.VITE_REST_SERVER_URL}/follows/follow/${id}`);
    console.log(result.data);
    return result.data;
  }

  async unfollowUser(id: string):Promise<void> {
    console.log(`Unfollowing user with ID: ${id}`);
    const response = await axios.post(`${import.meta.env.VITE_REST_SERVER_URL}/follows/unfollow/${id}`);
    return response.data;
  }

  async getFollowing(): Promise<User[]> {
    console.log("Fetching following...");
    const response = await axios.get<User[]>(`${import.meta.env.VITE_REST_SERVER_URL}/follows/following`);
    return response.data;
  }
}

const followerService = new FollowerService();
export default followerService;

# services/auth-aware/Profile.ts
// services/auth-aware/Profile.ts
import axios from "axios";
import Post from "../../models/posts/Post";
import PostDraft from "../../models/posts/PostDraft";
import Comment from "../../models/comment/Comments";
import AuthAware from "./AuthAware";

export default class Profile extends AuthAware {
    private baseUrl = import.meta.env.VITE_REST_SERVER_URL_SAFE;

    async getProfile(): Promise<Post[]> {
        try {
            console.log("Fetching posts from:", `${this.baseUrl}/posts`);
            const response = await this.axiosInstance.get<Post[]>(`${this.baseUrl}/posts`);
            console.log("API Response:", response.data);
            return response.data;
        } catch (error) {
            console.error("Error fetching posts:", error);
            throw error;
        }
    }

    async addPost(post: PostDraft): Promise<Post> {
        try {
            const response = await this.axiosInstance.post(
                `${this.baseUrl}/posts`,
                post
            );
            return response.data;
        } catch (error) {
            console.error("Error adding post:", error);
            throw error;
        }
    }

    async updatePost(id: string, post: PostDraft): Promise<Post> {
        try {
            const response = await this.axiosInstance.patch(
                `${this.baseUrl}/posts/${id}`,
                post
            );
            return response.data;
        } catch (error) {
            console.error("Error updating post:", error);
            throw error;
        }
    }

    async removePost(id: string): Promise<void> {
        try {
            await this.axiosInstance.delete(`${this.baseUrl}/posts/${id}`);
        } catch (error) {
            console.error("Error removing post:", error);
            throw error;
        }
    }

    async addComment(postId: string, body: string): Promise<Comment> {
        try {
            const response = await this.axiosInstance.post(
                `${this.baseUrl}/comments/${postId}`,
                { body }
            );
            return response.data;
        } catch (error) {
            console.error("Error adding comment:", error);
            throw error;
        }
    }
}
# services/auth.ts
import axios from "axios";
import Login from "../models/users/Login";

class Auth {
    async login(login: Login) {
        const response = await axios.post<{jwt: string}>(`${import.meta.env.VITE_REST_SERVER_URL_SAFE}/auth/login`, login);
    return response.data.jwt;
    }
}
const auth = new Auth();
export default auth;
# services/Feed.ts
import axios from "axios";
import Post from "../models/posts/Post";

class Feed {
    async getFeed(): Promise<Post[]> {
        const response = await axios.get<Post[]>(`${import.meta.env.VITE_REST_SERVER_URL}/feed`);
        return response.data;
    }
}

const feed = new Feed();
console.log(feed);
export default feed;
# services/GetSinglePost.ts
import axios from "axios";
import Post from "../models/posts/Post";
// import PostDraft from "../models/posts/PostDraft";

class GetSinglePost {
    async getSinglePost(id:string): Promise<Post[]> {
        const response = await axios.get<Post[]>(`${import.meta.env.VITE_REST_SERVER_URL}/posts/${id}`);
        return response.data;
    }

}

const getSinglePost = new GetSinglePost();
console.log(getSinglePost);
export default getSinglePost;
# services/InsertPost.ts
import axios from "axios";
import PostDraft from "../models/posts/PostDraft";
import PostModel from '../models/posts/Post';

export default async function InsertPost(post: PostDraft):Promise<PostModel> {
  const jsonData = JSON.stringify(post);
  const response = await axios.post(
    `${import.meta.env.VITE_REST_SERVER_URL}/posts`,
    jsonData,
    {
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  console.log(response);
  return response.data as PostModel;
}

# services/Profile.ts
// services/Profile.ts
import axios from "axios";
import Post from "../models/posts/Post";
import PostDraft from "../models/posts/PostDraft";
import Comment from "../models/comment/Comments";

class Profile {
    private baseURL: string;

    constructor() {
        this.baseURL = import.meta.env.VITE_REST_SERVER_URL;
        console.log("API Base URL:", this.baseURL); // Debug log
    }

    async getProfile(): Promise<Post[]> {
        try {
            console.log("Fetching posts from:", `${this.baseURL}/posts`); // Debug log
            const response = await axios.get<Post[]>(`${this.baseURL}/posts`);
            console.log("API Response:", response.data); // Debug log
            return response.data;
        } catch (error) {
            console.error("Error fetching posts:", error); // Debug log
            throw error;
        }
    }

    async addPost(post: PostDraft): Promise<Post> {
        try {
            console.log("Adding post:", post); // Debug log
            const response = await axios.post(
                `${this.baseURL}/posts`,
                post,
                {
                    headers: {
                        "Content-Type": "application/json",
                    },
                }
            );
            console.log("Add post response:", response.data); // Debug log
            return response.data;
        } catch (error) {
            console.error("Error adding post:", error); // Debug log
            throw error;
        }
    }

    async updatePost(id: string, post: PostDraft): Promise<Post> {
        try {
            console.log("Updating post:", id, post); // Debug log
            const response = await axios.patch(
                `${this.baseURL}/posts/${id}`,
                post,
                {
                    headers: {
                        "Content-Type": "application/json",
                    },
                }
            );
            console.log("Update post response:", response.data); // Debug log
            return response.data;
        } catch (error) {
            console.error("Error updating post:", error); // Debug log
            throw error;
        }
    }

    async removePost(id: string): Promise<void> {
        try {
            console.log("Removing post:", id); // Debug log
            await axios.delete(`${this.baseURL}/posts/${id}`);
            console.log("Post removed successfully"); // Debug log
        } catch (error) {
            console.error("Error removing post:", error); // Debug log
            throw error;
        }
    }

    async addComment(postId: string, body: string): Promise<Comment> {
        try {
            console.log("Adding comment to post:", postId, body); // Debug log
            const response = await axios.post(
                `${this.baseURL}/comments/${postId}`,
                { body },
                {
                    headers: {
                        "Content-Type": "application/json",
                    },
                }
            );
            console.log("Add comment response:", response.data); // Debug log
            return response.data;
        } catch (error) {
            console.error("Error adding comment:", error); // Debug log
            throw error;
        }
    }
}

const profile = new Profile();
export default profile;
# services/updatePost.ts
import axios from "axios";
import Post from "../models/posts/Post";
import PostDraft from "../models/posts/PostDraft";

export default async function updatePost(id: string, post: PostDraft): Promise<Post> {
// now we will make that post .title and .body will be into a json object
console.log("Post:", post);
const jsonData = JSON.stringify(post);
  const response = await axios.patch(
    `${import.meta.env.VITE_REST_SERVER_URL}/posts/${id}`,
    jsonData,
    {
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  console.log("Response from updatePost:", response);
  return response.data
}

# vite-env.d.ts
/// <reference types="vite/client" />

